# Overview

Signalboost is a messaging service that allows small groups of admins to send encrypted "broadcast" messages to and receive encrypted "hotline" messages from groups of up to several thousand subscribers over the Signal Messaging Service.

Two of its important design properties are:

1. Admins and subscribers can send encrypted messages to each other without knowing each other's phone numbers or any other personally identifying information about each other
2. If a user's phone is seized or otherwise compromised, no identifying information about the admins or subscribers is leaked to the person who has compromised the phone

We currently achieve these objectives by:

a. Routing messages between admins and subscribers through a proxy signal phone number controlled by the Signalboost server(s)
b. Storing admin and subscriber phone numbers in cleartext membership tables in a postgres database on the Signalboost server (necessary for routing messages and checking admin permissions)
c. Storing key material and other metadata (including user phone numbers) contained in the Signal Protocol Store on Signal Servers (necessary to advance the Signal double-ratchet algorithm between proxy phone numbers and user phone numbers, so that they may exchange messages).

This design leaves valuable metadata about which phone numbers use which Signalboost channels (and, in some cases, when they use the channel) vulnerable to seizure by an adversary who can compromise the Signalboost server either by technical attack, legal compulsion, or social engineering of a project maintainer.

The purpose of this design doc is to design a system for maintaining the above desirable properties of concealing user identities from each other while rendering the system resilient to the above attacks that render it vulnerable to leaking user identities to someone with control of the Signalboost server(s).

We first outline the contours of our security objectives, threat model, and design constraints, then proceed to offer two potential designs to achieve our objectives given our threat model and constraints.

Both designs involve some variation on encrypting user data at rest to the public key of an asymmetric keypair, the private key of which is controlled by users, stored on a client not accessible to the Signalboost server, and transmitted to the server to temporarily decrypt and re-encrypt data on an as-needed basis.

This is intended to be a living document.

Its revision history can be accessed here:

https://0xacab.org/team-friendo/signalboost/-/merge_requests/487/commits

Anyone may offer comment, critique, or suggested revisions here:

https://0xacab.org/team-friendo/signalboost/-/merge_requests/487

# Security Objectives

TK-TODO

# Threat Model

## Assets

TK-TODO

## Adversaries

TK-TODO

## Attacks

TK-TODO

# Design Constraints

TK-TODO

# Proposed Design(s)

## Foundation

### Encryption of user data to key not controlled by server

By default, all identifying user data for a given channel -- by which we mean the rows in the membership table corresponding to a given channel and the serialized data from the Signal Protocol Store, which may either be in database tables or serialized to the filesystem in JSON format -- will be encrypted to the public key of an asymmetric keypair.

The private key of this keypair will be stored on the Signalboost server, but it will be encrypted to a symmetric key that is generated by an external client and is not stored on the server, such that only a client that can provide this secret key material can control the private key and thus decrypt the user data.

Whenever a client wishes to perform operations that require access to user metadata (such as routing broadcast messages from admins to subscribers or routing hotline messages from subscribers to admins), it will use the symmetric secret key to decrypt the private key and use the private key to decrypt the relevant user data.

All decryption operations will only load cleartext data into memory. At no point will unencrypted data be persisted to disk. When the necessary operations are complete, decrypted key material and user data will be wiped from memory, leaving the only accessible version of the data in an encrypted state.

For ease of communication, we will refer to this process of decrypting key material and user data as "unlocking" and "locking" a channel. There are several possibilities for how and when the unlock/lock cycle may be triggered by a client, which we will address in the "Variations on client-server key transmission" section below.

### Transmission of key from client to server

Admins install a client application, which may run as either a native desktop application or a native Android or IOS app. Upon creation of a new channel, the client application generates key material which is stored locally on the filesystem such that only the client may access it.

All messages to and from Signalboost are composed and displayed in the client. When an admin wishes to send or receive messages, the client connects to the Signalboost server over HTTPS (or any suitably secure network protocol), and transmits the key material necessary to "unlock" the channel as described above.

When a channel with multiple admins is created, or when an existing channel adds a new admin, key material will have to be exchanged between clients in a way that does not require the Signalboost server to already know their identities. There are several variations on how this may happen, which we will address in the "Variations on client-client key transmission" section below.

### Variations on client-server key transmission

#### Variation 1: Automated Client Polling + As-Needed Decryption

#### Variation 2: Notify Rotating List of Admins + Manually Prompted Decryption

### Variations on client-client key transmission



# Potential Design 2: Push Notifications to Rotating List of Notificees
